## Authentication (Auth) — reference

This document explains how authentication works in this project, the routes involved, the database shape, helpers/plugins used, and common edge cases.

### Quick summary
- Auth uses JWTs for API authentication and an HTTP-only cookie (`authToken`) for browser sessions.
- Passwords are hashed with bcrypt (saltRounds = 12).
- DB table: `users` (id UUID PK, email unique, password_hash, created_at, updated_at).
- Routes live under `/auth/*` (see list below).

## Routes

All responses follow the standardized response format: success responses are `{ success: true, data: ..., message?: string }`. Errors are `{ success: false, error: string, details?: any }`.

- POST /auth/signup
  - Body: { email: string, password: string } (password minLength 5)
  - Behavior: if email exists -> 409. Otherwise hash password, create user, sign JWT, set auth cookie, return 201 with `{ user: { id, email }, token }`.

- POST /auth/login
  - Body: { email: string, password: string }
  - Behavior: verify user and bcrypt.compare password. On success sign JWT, set auth cookie, return 200 with `{ user: { id, email }, token }`. Invalid credentials -> 401.

- POST /auth/logout
  - Auth required (uses `fastify.authenticate`). Clears the `authToken` cookie. Returns 200 empty success.

- GET /auth/me
  - Auth required. Uses the JWT payload (available as `request.user`) to fetch user row and return `{ user: { id, email } }`.

- PUT /auth/update-password
  - Auth required. Body: { currentPassword: string, newPassword: string } (newPassword minLength 5)
  - Behavior: verifies current password, disallows setting same password, hashes new password and updates `password_hash` and `updated_at`.

- POST /auth/forgot-password
  - Body: { email: string }
  - Behavior: Generates a secure, URL-safe random token, stores only its SHA256 hash in `password_reset_tokens` with an expiry (default 60 minutes, configurable via `PASSWORD_RESET_TOKEN_EXPIRES_MINUTES`), and sends a password reset link to the user's email. Always returns 200 with a generic message so callers cannot enumerate whether the email exists.

- POST /auth/reset-password
  - Body: { token: string, email: string, newPassword: string } (newPassword minLength 5)
  - Behavior: Verifies the provided token by hashing it (SHA256) and looking up the `password_reset_tokens` row joined to the user by email. Rejects when the token is missing/invalid, already used, or expired (401). Disallows setting the same password as before (400). On success, updates the user's `password_hash`, marks the token as used (`used = true`, `used_at`), optionally signs the user in (JWT + `authToken` cookie) and returns success with the newly issued token in the response.

## Plugins & helpers (what to call / what they do)

- `src/plugins/auth.ts`
  - Exposes `fastify.authenticate(request, reply)` — middleware that runs `request.jwtVerify()` and returns standardized error responses for missing/expired/invalid tokens.
  - `fastify.authenticateOptional` — attempts verify but silently continues if no token.
  - `fastify.createJWTPayload(user)` — helper to build JWT payload { id, email }.

- `src/plugins/jwt.ts`
  - Registers `@fastify/jwt` with config: `secret = fastify.config.JWT_SECRET`, `sign.expiresIn = fastify.config.JWT_EXPIRES_IN || '30d'`.
  - Configures cookie support: `cookieName: 'authToken'` and custom error messages.
  - Adds reply helpers: `reply.setAuthCookie(token)` and `reply.clearAuthCookie()`.
    - Cookie options: `httpOnly: true`, `sameSite: 'none'`, `maxAge: 30 days` (ms), `secure` and `domain` only in production (`fastify.config.NODE_ENV === 'production'` and `fastify.config.COOKIE_DOMAIN`).

- `src/plugins/cookie.ts`
  - Registers `@fastify/cookie` and configures signed cookie secret from `fastify.config.COOKIE_SECRET` (optional).

- `src/plugins/kysely.ts`
  - Exposes `fastify.kysely` (Kysely instance) connected to Postgres using `fastify.config.DATABASE_URL`.

- `src/lib/response-format.ts`
  - Provides `successResponse()`, `emptySuccessResponse()`, `errorResponse()`, and schema wrappers used by route schemas.

- Email sending: routes use `fastify.sendEmail(to, subject, html)`; email delivery failures are logged but do not change the HTTP response for the `forgot-password` flow (to avoid leaking information).

## Database schema (users)

- Table: `users`
  - id: UUID PRIMARY KEY DEFAULT gen_random_uuid()
  - email: VARCHAR(255) NOT NULL UNIQUE
  - password_hash: VARCHAR(255) NOT NULL
  - created_at: TIMESTAMPTZ NOT NULL DEFAULT now()
  - updated_at: TIMESTAMPTZ NOT NULL DEFAULT now() (trigger updates on UPDATE)

TypeScript DB types are in `src/types/database.ts` (generated by Kysely codegen). The `users` interface includes `password_hash` as stored value.

## Password reset tokens (table: password_reset_tokens)

- Purpose: store a hashed verification token used for password reset flows.
- Typical columns:
  - `id`: PK (UUID)
  - `user_id`: FK -> `users.id`
  - `token_hash`: string (SHA256 of the token provided to the user)
  - `expires_at`: timestamptz
  - `used`: boolean (default false)
  - `used_at`: timestamptz | null
  - `created_at`: timestamptz

- Notes:
  - The actual token sent to users is a URL-safe base64 string (generated from 48 random bytes) and is never stored in plaintext — only its SHA256 hash is stored.
  - Tokens should be validated by hashing the presented token and comparing `token_hash`, ensuring `used` is false and `expires_at` is in the future.

## Token & cookie details

- JWT
  - Created with `reply.jwtSign(payload)` where `payload` comes from `fastify.createJWTPayload({ id, email })`.
  - `expiresIn` defaults to `'30d'` but is configurable via `fastify.config.JWT_EXPIRES_IN`.

- Cookie (`authToken`)
  - Set using `reply.setAuthCookie(token)` after successful signup/login.
  - Cookie options: httpOnly, sameSite='none', maxAge 30 days (ms), secure and domain only in production.
  - Clearing via `reply.clearAuthCookie()` (used by logout).

  Note: the password reset flow may sign the user in after a successful reset by generating a JWT with `fastify.createJWTPayload(...)`, calling `reply.jwtSign(...)` and `reply.setAuthCookie(...)`. The signed token is also returned in the JSON response for non-cookie clients.

## Error handling patterns

- Validation errors are handled by TypeBox schemas and Fastify; route code returns `reply.code(...).send(errorResponse(...))` for known error cases.
- `src/plugins/error-handler.ts` centralizes error formatting in the app. Route-level try/catch logs via `fastify.log.error()` and returns standardized error responses.

Specific to password reset flows:
- `forgot-password` always returns a generic 200 success message to avoid user enumeration. Email delivery errors are logged but do not alter this response.
- `reset-password` returns 401 for invalid/expired/used tokens, 400 for validation errors (for example, attempting to reuse the same password), and 200 on success.

## Contract (short)

- Inputs: route-specific JSON bodies or Authorization (cookie or Bearer token). Auth decorators read JWT from cookie `authToken` or `Authorization: Bearer <token>` header.
- Outputs: standardized success/error shapes described above.
- Error modes: invalid credentials (401), token missing/expired/invalid (401), malformed token (400), unique email conflict (409), DB errors (400/500 depending on handler).

## Common edge cases

- Signup with an existing email -> 409 Conflict.
- Login with wrong email or wrong password -> 401 Invalid credentials.
- Missing token or expired token -> 401 from `fastify.authenticate`.
- Attempting to set the same password in update-password -> 400.
- Tokens are accepted from either cookie or Authorization header; cookie is preferred for browser flows.

- Forgot/reset specific:
  - Signup or forgot requests for the same email should not reveal whether an account exists (generic 200 response).
  - Reset tokens are one-time use: attempts to reuse the same token should return 401.
  - Expired tokens return 401.
  - If sending the reset email fails, the flow still returns the generic success message; errors are logged for operators to inspect.
  - Reset must verify the token against the hashed value stored in `password_reset_tokens` and confirm the token belongs to the user identified by the `email` parameter.

## Tests

Relevant tests are in `test/routes/auth/*.test.ts` for each route and `test/plugins/auth.test.ts`, `test/plugins/jwt.test.ts` for plugin behavior. The password reset flow has corresponding route tests (see `test/routes/auth/reset-password.test.ts` and `test/routes/auth/forgot-password.test.ts` if present). Run them with the project's test scripts (see `package.json`).

## Examples (curl)

Signup (returns token and sets cookie):

```bash
curl -X POST -H "Content-Type: application/json" \
  -d '{"email":"me@example.com","password":"s3cretpw"}' \
  http://localhost:3000/auth/signup
```

Login:

```bash
curl -X POST -H "Content-Type: application/json" \
  -d '{"email":"me@example.com","password":"s3cretpw"}' \
  http://localhost:3000/auth/login
```

Get current user (using cookie set by the previous requests):

```bash
curl -b "authToken=<cookie-value>" http://localhost:3000/auth/me
```

Or using bearer token returned in JSON:

```bash
curl -H "Authorization: Bearer <token>" http://localhost:3000/auth/me
```
